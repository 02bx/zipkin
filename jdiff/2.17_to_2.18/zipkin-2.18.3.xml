<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Fri May 29 23:40:56 CEST 2020 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="zipkin-2.18.3"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/heymjo/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar:/home/heymjo/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/heymjo/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/heymjo/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar -doclet jdiff.JDiff -docletpath /home/heymjo/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar:/home/heymjo/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/heymjo/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/heymjo/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar -apiname zipkin-2.18.3 -apidir /home/heymjo/src/zipkin/jdiff/2.17_to_2.18 -classpath /home/heymjo/.m2/repository/com/google/code/gson/gson/2.8.5/gson-2.8.5.jar:/home/heymjo/.m2/repository/io/zipkin/zipkin2/zipkin/2.18.3/zipkin-2.18.3.jar -sourcepath /tmp/jdiff3535481176160448385/zipkin/2.18.3/sources -->
<package name="zipkin2">
  <!-- start class zipkin2.Annotation -->
  <class name="Annotation" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <implements name="java.io.Serializable"/>
    <method name="create" return="zipkin2.Annotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="timestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Microseconds from epoch.

 <p>This value should be set directly by instrumentation, using the most precise value possible.
 For example, {@code gettimeofday} or multiplying {@link System#currentTimeMillis} by 1000.]]>
      </doc>
    </method>
    <method name="value" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Usually a short tag indicating an event, like {@code cache.miss} or {@code error}]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="zipkin2.Annotation"/>
      <doc>
      <![CDATA[Compares by {@link #timestamp}, then {@link #value}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Associates an event that explains latency with a timestamp.

 <p>Unlike log statements, annotations are often codes: Ex. {@code cache.miss}.]]>
    </doc>
  </class>
  <!-- end class zipkin2.Annotation -->
  <!-- start class zipkin2.Call -->
  <class name="Call" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="Call"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="zipkin2.Call"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a completed call which has the supplied value. This is useful when input parameters
 imply there's no call needed. For example, an empty input might always result in an empty
 output.]]>
      </doc>
    </method>
    <method name="emptyList" return="zipkin2.Call"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="map" return="zipkin2.Call"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="mapper" type="zipkin2.Call.Mapper"/>
      <doc>
      <![CDATA[Maps the result of this call into a different shape, as defined by the {@code mapper} function.
 This is used to convert values from one type to another. For example, you could use this to
 convert between zipkin v1 and v2 span format.

 <pre>{@code
 getTracesV1Call = getTracesV2Call.map(traces -> v2TracesConverter);
 }</pre>

 <p>This method intends to be used for chaining. That means "this" instance should be discarded
 in favor of the result of this method.]]>
      </doc>
    </method>
    <method name="flatMap" return="zipkin2.Call"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="flatMapper" type="zipkin2.Call.FlatMapper"/>
      <doc>
      <![CDATA[Maps the result of this call into another, as defined by the {@code flatMapper} function. This
 is used to chain two remote calls together. For example, you could use this to chain a list IDs
 call to a get by IDs call.

 <pre>{@code
 getTracesCall = getIdsCall.flatMap(ids -> getTraces(ids));

 // this would now invoke the chain
 traces = getTracesCall.enqueue(tracesCallback);
 }</pre>

 Cancelation propagates to the mapped call.

 <p>This method intends to be used for chaining. That means "this" instance should be discarded
 in favor of the result of this method.]]>
      </doc>
    </method>
    <method name="handleError" return="zipkin2.Call"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="errorHandler" type="zipkin2.Call.ErrorHandler"/>
      <doc>
      <![CDATA[Returns a call which can attempt to resolve an exception. This is useful when a remote call
 returns an error when a resource is not found.

 <p>Here's an example of coercing 404 to empty:
 <pre>{@code
 call.handleError((error, callback) -> {
   if (error instanceof HttpException && ((HttpException) error).code == 404) {
     callback.onSuccess(Collections.emptyList());
   } else {
     callback.onError(error);
   }
 });
 }</pre>]]>
      </doc>
    </method>
    <method name="propagateIfFatal"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="execute" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Invokes a request, returning a success value or propagating an error to the caller. Invoking
 this more than once will result in an error. To repeat a call, make a copy with {@linkplain
 #clone()}.

 <p>Eventhough this is a blocking call, implementations may honor calls to {@linkplain
 #cancel()} from a different thread.

 @return a success value. Null is unexpected, except when {@code V} is {@linkplain Void}.]]>
      </doc>
    </method>
    <method name="enqueue"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callback" type="zipkin2.Callback"/>
      <doc>
      <![CDATA[Invokes a request asynchronously, signaling the {@code callback} when complete. Invoking this
 more than once will result in an error. To repeat a call, make a copy with {@linkplain
 #clone()}.]]>
      </doc>
    </method>
    <method name="cancel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Requests to cancel this call, even if some implementations may not support it. For example, a
 blocking call is sometimes not cancelable.]]>
      </doc>
    </method>
    <method name="isCanceled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if {@linkplain #cancel()} was called.

 <p>Calls can fail before being canceled, so true does always mean cancelation caused a call to
 fail. That said, successful cancellation does result in a failure.]]>
      </doc>
    </method>
    <method name="clone" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a copy of this object, so you can make an identical follow-up request.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This captures a (usually remote) request and can be used once, either {@link #execute()
 synchronously} or {@link #enqueue(Callback) asynchronously}. At any time, from any thread, you
 can call {@linkplain #cancel()}, which might stop an in-flight request or prevent one from
 occurring.

 <p>Implementations should prepare a call such that there's little or no likelihood of late
 runtime exceptions. For example, if the call is to get a trace, the call to {@code listSpans}
 should propagate input errors vs delay them until a call to {@linkplain #execute()} or
 {@linkplain #enqueue(Callback)}.

 <p>Ex.
 <pre>{@code
 // Any translation of an input request to remote parameters should happen here, and any related
 // errors should propagate here.
 Call<List<List<Span>>> listTraces = spanStore.listTraces(request);
 // When this executes, it should simply run the remote request.
 List<Span> trace = getTraceCall.execute();
 }</pre>

 <p>An instance of call cannot be invoked more than once, but you can {@linkplain #clone()} an
 instance if you need to replay the call. There is no relationship between a call and a number of
 remote requests. For example, an implementation that stores spans may make hundreds of remote
 requests, possibly retrying on your behalf.

 <p>This type owes its design to {@code retrofit2.Call}, which is nearly the same, except limited
 to HTTP transports.

 @param <V> the success type, typically not null except when {@code V} is {@linkplain Void}.]]>
    </doc>
  </class>
  <!-- end class zipkin2.Call -->
  <!-- start class zipkin2.Call.Base -->
  <class name="Call.Base" extends="zipkin2.Call"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Base"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="execute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="doExecute" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="enqueue"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="callback" type="zipkin2.Callback"/>
    </method>
    <method name="doEnqueue"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="callback" type="zipkin2.Callback"/>
    </method>
    <method name="cancel"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doCancel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="isCanceled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doIsCanceled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class zipkin2.Call.Base -->
  <!-- start interface zipkin2.Call.ErrorHandler -->
  <interface name="Call.ErrorHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onErrorReturn"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Throwable"/>
      <param name="callback" type="zipkin2.Callback"/>
      <doc>
      <![CDATA[Attempts to resolve an error. The user must call the callback.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface zipkin2.Call.ErrorHandler -->
  <!-- start interface zipkin2.Call.FlatMapper -->
  <interface name="Call.FlatMapper"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="map" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
    </method>
  </interface>
  <!-- end interface zipkin2.Call.FlatMapper -->
  <!-- start interface zipkin2.Call.Mapper -->
  <interface name="Call.Mapper"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="map" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
    </method>
  </interface>
  <!-- end interface zipkin2.Call.Mapper -->
  <!-- start interface zipkin2.Callback -->
  <interface name="Callback"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onSuccess"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Invoked when computation produces its potentially null value successfully.

 <p>When this is called, {@link #onError} won't be.]]>
      </doc>
    </method>
    <method name="onError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Invoked when computation produces a possibly null value successfully.

 <p>When this is called, {@link #onSuccess} won't be.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback of a single result or error.

 <p>This is a bridge to async libraries such as CompletableFuture complete, completeExceptionally.

 <p>Implementations will call either {@link #onSuccess} or {@link #onError}, but not both.]]>
    </doc>
  </interface>
  <!-- end interface zipkin2.Callback -->
  <!-- start class zipkin2.CheckResult -->
  <class name="CheckResult" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="failed" return="zipkin2.CheckResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Throwable"/>
    </method>
    <method name="ok" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="error" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Present when not ok]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="OK" type="zipkin2.CheckResult"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Answers the question: Are operations on this component likely to succeed?

 <p>Implementations should initialize the component if necessary. It should test a remote
 connection, or consult a trusted source to derive the result. They should use least resources
 possible to establish a meaningful result, and be safe to call many times, even concurrently.

 @see CheckResult#OK]]>
    </doc>
  </class>
  <!-- end class zipkin2.CheckResult -->
  <!-- start class zipkin2.Component -->
  <class name="Component" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="Component"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="check" return="zipkin2.CheckResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Answers the question: Are operations on this component likely to succeed?

 <p>Implementations should initialize the component if necessary. It should test a remote
 connection, or consult a trusted source to derive the result. They should use least resources
 possible to establish a meaningful result, and be safe to call many times, even concurrently.

 @see CheckResult#OK]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes any network resources created implicitly by the component.

 <p>For example, if this created a connection, it would close it. If it was provided one, this
 would close any sessions, but leave the connection open.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Components are object graphs used to compose a zipkin service or client. For example, a storage
 component might return a query api.

 <p>Components are lazy with regards to I/O. They can be injected directly to other components so
 as to avoid crashing the application graph if a network service is unavailable.]]>
    </doc>
  </class>
  <!-- end class zipkin2.Component -->
  <!-- start class zipkin2.DependencyLink -->
  <class name="DependencyLink" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="newBuilder" return="zipkin2.DependencyLink.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parent" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[parent service name (caller)]]>
      </doc>
    </method>
    <method name="child" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[child service name (callee)]]>
      </doc>
    </method>
    <method name="callCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[total traced calls made from {@link #parent} to {@link #child}]]>
      </doc>
    </method>
    <method name="errorCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[How many {@link #callCount calls} are known to be errors]]>
      </doc>
    </method>
    <method name="toBuilder" return="zipkin2.DependencyLink.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class zipkin2.DependencyLink -->
  <!-- start class zipkin2.DependencyLink.Builder -->
  <class name="DependencyLink.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="parent" return="zipkin2.DependencyLink.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="java.lang.String"/>
    </method>
    <method name="child" return="zipkin2.DependencyLink.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="child" type="java.lang.String"/>
    </method>
    <method name="callCount" return="zipkin2.DependencyLink.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callCount" type="long"/>
    </method>
    <method name="errorCount" return="zipkin2.DependencyLink.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errorCount" type="long"/>
    </method>
    <method name="build" return="zipkin2.DependencyLink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class zipkin2.DependencyLink.Builder -->
  <!-- start class zipkin2.Endpoint -->
  <class name="Endpoint" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="serviceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Lower-case label of this node in the service graph, such as "favstar". Leave absent if
 unknown.

 <p>This is a primary label for trace lookup and aggregation, so it should be intuitive and
 consistent. Many use a name from service discovery.]]>
      </doc>
    </method>
    <method name="ipv4" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The text representation of the primary IPv4 address associated with this a connection. Ex.
 192.168.99.100 Absent if unknown.]]>
      </doc>
    </method>
    <method name="ipv4Bytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[IPv4 endpoint address packed into 4 bytes or null if unknown.

 @see #ipv6()
 @see java.net.Inet4Address#getAddress()]]>
      </doc>
    </method>
    <method name="ipv6" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The text representation of the primary IPv6 address associated with this a connection. Ex.
 2001:db8::c001 Absent if unknown.

 @see #ipv4() for mapped addresses
 @see #ipv6Bytes()]]>
      </doc>
    </method>
    <method name="ipv6Bytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[IPv6 endpoint address packed into 16 bytes or null if unknown.

 @see #ipv6()
 @see java.net.Inet6Address#getAddress()]]>
      </doc>
    </method>
    <method name="port" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Port of the IP's socket or null, if not known.

 @see java.net.InetSocketAddress#getPort()]]>
      </doc>
    </method>
    <method name="portAsInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Like {@link #port()} except returns a primitive where zero implies absent.

 <p>Using this method will avoid allocation, so is encouraged when copying data.]]>
      </doc>
    </method>
    <method name="toBuilder" return="zipkin2.Endpoint.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newBuilder" return="zipkin2.Endpoint.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The network context of a node in the service graph.]]>
    </doc>
  </class>
  <!-- end class zipkin2.Endpoint -->
  <!-- start class zipkin2.Endpoint.Builder -->
  <class name="Endpoint.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="serviceName" return="zipkin2.Endpoint.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceName" type="java.lang.String"/>
      <doc>
      <![CDATA[@see Endpoint#serviceName]]>
      </doc>
    </method>
    <method name="ip" return="zipkin2.Endpoint.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Chaining variant of {@link #parseIp(InetAddress)}]]>
      </doc>
    </method>
    <method name="parseIp" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns true if {@link Endpoint#ipv4()} or {@link Endpoint#ipv6()} could be parsed from the
 input.

 <p>Returns boolean not this for conditional parsing. For example:
 <pre>{@code
 if (!builder.parseIp(input.getHeader("X-Forwarded-For"))) {
   builder.parseIp(input.getRemoteAddr());
 }
 }</pre>

 @see #parseIp(String)]]>
      </doc>
    </method>
    <method name="parseIp" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ipBytes" type="byte[]"/>
      <doc>
      <![CDATA[Like {@link #parseIp(String)} except this accepts a byte array.

 @param ipBytes byte array whose ownership is exclusively transferred to this endpoint.]]>
      </doc>
    </method>
    <method name="ip" return="zipkin2.Endpoint.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Chaining variant of {@link #parseIp(String)}]]>
      </doc>
    </method>
    <method name="parseIp" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if {@link Endpoint#ipv4()} or {@link Endpoint#ipv6()} could be parsed from the
 input.

 <p>Returns boolean not this for conditional parsing. For example:
 <pre>{@code
 if (!builder.parseIp(input.getHeader("X-Forwarded-For"))) {
   builder.parseIp(input.getRemoteAddr());
 }
 }</pre>

 @see #parseIp(InetAddress)]]>
      </doc>
    </method>
    <method name="port" return="zipkin2.Endpoint.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="port" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Use this to set the port to an externally defined value.

 @param port port associated with the endpoint. zero coerces to null (unknown)
 @see Endpoint#port()]]>
      </doc>
    </method>
    <method name="port" return="zipkin2.Endpoint.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="port" type="int"/>
      <doc>
      <![CDATA[@see Endpoint#portAsInt()]]>
      </doc>
    </method>
    <method name="build" return="zipkin2.Endpoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class zipkin2.Endpoint.Builder -->
  <!-- start class zipkin2.Span -->
  <class name="Span" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="traceId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Trace identifier, set on all spans within it.

 <p>Encoded as 16 or 32 lowercase hex characters corresponding to 64 or 128 bits. For example,
 a 128bit trace ID looks like {@code 4e441824ec2b6a44ffdc9bb9a6453df3}.

 <p>Some systems downgrade trace identifiers to 64bit by dropping the left-most 16 characters.
 For example, {@code 4e441824ec2b6a44ffdc9bb9a6453df3} becomes {@code ffdc9bb9a6453df3}.]]>
      </doc>
    </method>
    <method name="parentId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The parent's {@link #id} or null if this the root span in a trace.

 <p>This is the same encoding as {@link #id}. For example {@code ffdc9bb9a6453df3}]]>
      </doc>
    </method>
    <method name="id" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unique 64bit identifier for this operation within the trace.

 <p>Encoded as 16 lowercase hex characters. For example {@code ffdc9bb9a6453df3}

 <p>A span is uniquely identified in storage by ({@linkplain #traceId}, {@linkplain #id()}).]]>
      </doc>
    </method>
    <method name="kind" return="zipkin2.Span.Kind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When present, used to interpret {@link #remoteEndpoint}]]>
      </doc>
    </method>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Span name in lowercase, rpc method for example.

 <p>Conventionally, when the span name isn't known, name = "unknown".]]>
      </doc>
    </method>
    <method name="timestamp" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Epoch microseconds of the start of this span, possibly absent if this an incomplete span.

 <p>This value should be set directly by instrumentation, using the most precise value
 possible. For example, {@code gettimeofday} or multiplying {@link System#currentTimeMillis} by
 1000.

 <p>There are three known edge-cases where this could be reported absent:

 <pre><ul>
 <li>A span was allocated but never started (ex not yet received a timestamp)</li>
 <li>The span's start event was lost</li>
 <li>Data about a completed span (ex tags) were sent after the fact</li>
 </pre><ul>

 <p>Note: timestamps at or before epoch (0L == 1970) are invalid

 @see #duration()
 @see #timestampAsLong()]]>
      </doc>
    </method>
    <method name="timestampAsLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Like {@link #timestamp()} except returns a primitive where zero implies absent.

 <p>Using this method will avoid allocation, so is encouraged when copying data.]]>
      </doc>
    </method>
    <method name="duration" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Measurement in microseconds of the critical path, if known. Durations of less than one
 microsecond must be rounded up to 1 microsecond.

 <p>This value should be set directly, as opposed to implicitly via annotation timestamps.
 Doing so encourages precision decoupled from problems of clocks, such as skew or NTP updates
 causing time to move backwards.

 <p>If this field is persisted as unset, zipkin will continue to work, except duration query
 support will be implementation-specific. Similarly, setting this field non-atomically is
 implementation-specific.

 <p>This field is i64 vs i32 to support spans longer than 35 minutes.

 @see #durationAsLong()]]>
      </doc>
    </method>
    <method name="durationAsLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Like {@link #duration()} except returns a primitive where zero implies absent.

 <p>Using this method will avoid allocation, so is encouraged when copying data.]]>
      </doc>
    </method>
    <method name="localEndpoint" return="zipkin2.Endpoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The host that recorded this span, primarily for query by service name.

 <p>Instrumentation should always record this and be consistent as possible with the service
 name as it is used in search. This is nullable for legacy reasons.]]>
      </doc>
    </method>
    <method name="remoteEndpoint" return="zipkin2.Endpoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When an RPC (or messaging) span, indicates the other side of the connection.

 <p>By recording the remote endpoint, your trace will contain network context even if the peer
 is not tracing. For example, you can record the IP from the {@code X-Forwarded-For} header or
 the service name and socket of a remote peer.]]>
      </doc>
    </method>
    <method name="annotations" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Events that explain latency with a timestamp. Unlike log statements, annotations are often
 short or contain codes: for example "brave.flush". Annotations are sorted ascending by
 timestamp.]]>
      </doc>
    </method>
    <method name="tags" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tags a span with context, usually to support query or aggregation.

 <p>For example, a tag key could be {@code "http.path"}.]]>
      </doc>
    </method>
    <method name="debug" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[True is a request to store this span even if it overrides sampling policy.]]>
      </doc>
    </method>
    <method name="shared" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[True if we are contributing to a span started by another tracer (ex on a different host).
 Defaults to null. When set, it is expected for {@link #kind()} to be {@link Kind#SERVER}.

 <p>When an RPC trace is client-originated, it will be sampled and the same span ID is used for
 the server side. However, the server shouldn't set span.timestamp or duration since it didn't
 start the span.]]>
      </doc>
    </method>
    <method name="localServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remoteServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newBuilder" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toBuilder" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="normalizeTraceId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a valid lower-hex trace ID, padded left as needed to 16 or 32 characters.

 @throws IllegalArgumentException if oversized or not lower-hex]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A span is a single-host view of an operation. A trace is a series of spans (often RPC calls)
 which nest to form a latency tree. Spans are in the same trace when they share the same trace ID.
 The {@link #parentId} field establishes the position of one span in the tree.

 <p>The root span is where {@link #parentId} is null and usually has the longest {@link
 #duration} in the trace. However, nested asynchronous work can materialize as child spans whose
 duration exceed the root span.

 <p>Spans usually represent remote activity such as RPC calls, or messaging producers and
 consumers. However, they can also represent in-process activity in any position of the trace. For
 example, a root span could represent a server receiving an initial client request. A root span
 could also represent a scheduled job that has no remote context.

 <p>While span identifiers are packed into longs, they should be treated opaquely. ID encoding is
 16 or 32 character lower-hex, to avoid signed interpretation.

 <h3>Relationship to {@code zipkin.Span}</h3>

 <p>This type is intended to replace use of {@code zipkin.Span}. Particularly, tracers represent
 a single-host view of an operation. By making one endpoint implicit for all data, this type does
 not need to repeat endpoints on each data like {@code zipkin.Span} does. This results in simpler
 and smaller data.]]>
    </doc>
  </class>
  <!-- end class zipkin2.Span -->
  <!-- start class zipkin2.Span.Builder -->
  <class name="Span.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="clear" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="merge" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="zipkin2.Span"/>
      <doc>
      <![CDATA[Used to merge multiple incomplete spans representing the same operation on the same host. Do
 not use this to merge spans that occur on different hosts.]]>
      </doc>
    </method>
    <method name="kind" return="zipkin2.Span.Kind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="localEndpoint" return="zipkin2.Endpoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="traceId" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="java.lang.String"/>
      <doc>
      <![CDATA[@throws IllegalArgumentException if not lower-hex format
 @see Span#id()]]>
      </doc>
    </method>
    <method name="traceId" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="high" type="long"/>
      <param name="low" type="long"/>
      <doc>
      <![CDATA[Encodes 64 or 128 bits from the input into a hex trace ID.

 @param high Upper 64bits of the trace ID. Zero means the trace ID is 64-bit.
 @param low Lower 64bits of the trace ID.
 @throws IllegalArgumentException if both values are zero]]>
      </doc>
    </method>
    <method name="parentId" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentId" type="long"/>
      <doc>
      <![CDATA[Encodes 64 bits from the input into a hex parent ID. Unsets the {@link Span#parentId()} if
 the input is 0.

 @see Span#parentId()]]>
      </doc>
    </method>
    <method name="parentId" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentId" type="java.lang.String"/>
      <doc>
      <![CDATA[@throws IllegalArgumentException if not lower-hex format
 @see Span#parentId()]]>
      </doc>
    </method>
    <method name="id" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="long"/>
      <doc>
      <![CDATA[Encodes 64 bits from the input into a hex span ID.

 @throws IllegalArgumentException if the input is zero
 @see Span#id()]]>
      </doc>
    </method>
    <method name="id" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
      <doc>
      <![CDATA[@throws IllegalArgumentException if not lower-hex format
 @see Span#id()]]>
      </doc>
    </method>
    <method name="kind" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kind" type="zipkin2.Span.Kind"/>
      <doc>
      <![CDATA[@see Span#kind]]>
      </doc>
    </method>
    <method name="name" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[@see Span#name]]>
      </doc>
    </method>
    <method name="timestamp" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <doc>
      <![CDATA[@see Span#timestampAsLong()]]>
      </doc>
    </method>
    <method name="timestamp" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="java.lang.Long"/>
      <doc>
      <![CDATA[@see Span#timestamp()]]>
      </doc>
    </method>
    <method name="duration" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="long"/>
      <doc>
      <![CDATA[@see Span#durationAsLong()]]>
      </doc>
    </method>
    <method name="duration" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="java.lang.Long"/>
      <doc>
      <![CDATA[@see Span#duration()]]>
      </doc>
    </method>
    <method name="localEndpoint" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localEndpoint" type="zipkin2.Endpoint"/>
      <doc>
      <![CDATA[@see Span#localEndpoint]]>
      </doc>
    </method>
    <method name="remoteEndpoint" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="remoteEndpoint" type="zipkin2.Endpoint"/>
      <doc>
      <![CDATA[@see Span#remoteEndpoint]]>
      </doc>
    </method>
    <method name="addAnnotation" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[@see Span#annotations]]>
      </doc>
    </method>
    <method name="clearAnnotations" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Span#annotations]]>
      </doc>
    </method>
    <method name="putTag" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[@see Span#tags]]>
      </doc>
    </method>
    <method name="clearTags" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Span#tags]]>
      </doc>
    </method>
    <method name="debug" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="debug" type="boolean"/>
      <doc>
      <![CDATA[@see Span#debug]]>
      </doc>
    </method>
    <method name="debug" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="debug" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[@see Span#debug]]>
      </doc>
    </method>
    <method name="shared" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shared" type="boolean"/>
      <doc>
      <![CDATA[@see Span#shared]]>
      </doc>
    </method>
    <method name="shared" return="zipkin2.Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shared" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[@see Span#shared]]>
      </doc>
    </method>
    <method name="build" return="zipkin2.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class zipkin2.Span.Builder -->
  <!-- start class zipkin2.Span.Kind -->
  <class name="Span.Kind" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="zipkin2.Span.Kind[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="zipkin2.Span.Kind"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="CLIENT" type="zipkin2.Span.Kind"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SERVER" type="zipkin2.Span.Kind"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PRODUCER" type="zipkin2.Span.Kind"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When present, {@link #timestamp()} is the moment a producer sent a message to a destination.
 {@link #duration()} represents delay sending the message, such as batching, while {@link
 #remoteEndpoint()} indicates the destination, such as a broker.

 <p>Unlike {@link #CLIENT}, messaging spans never share a span ID. For example, the {@link
 #CONSUMER} of the same message has {@link #parentId()} set to this span's {@link #id()}.]]>
      </doc>
    </field>
    <field name="CONSUMER" type="zipkin2.Span.Kind"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When present, {@link #timestamp()} is the moment a consumer received a message from an
 origin. {@link #duration()} represents delay consuming the message, such as from backlog,
 while {@link #remoteEndpoint()} indicates the origin, such as a broker.

 <p>Unlike {@link #SERVER}, messaging spans never share a span ID. For example, the {@link
 #PRODUCER} of this message is the {@link #parentId()} of this span.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Indicates the primary span type.]]>
    </doc>
  </class>
  <!-- end class zipkin2.Span.Kind -->
  <!-- start class zipkin2.SpanBytesDecoderDetector -->
  <class name="SpanBytesDecoderDetector" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="decoderForMessage" return="zipkin2.codec.BytesDecoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="span" type="byte[]"/>
      <doc>
      <![CDATA[@throws IllegalArgumentException if the input isn't a v1 json or thrift single-span message]]>
      </doc>
    </method>
    <method name="decoderForListMessage" return="zipkin2.codec.BytesDecoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spans" type="byte[]"/>
      <doc>
      <![CDATA[@throws IllegalArgumentException if the input isn't a json, proto3 or thrift list message.]]>
      </doc>
    </method>
    <method name="decoderForListMessage" return="zipkin2.codec.BytesDecoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spans" type="java.nio.ByteBuffer"/>
    </method>
    <doc>
    <![CDATA[Detecting decoder used in transports which don't include means to identify the type of the data.

 <p>For example, we can identify the encoding and also the format in http via the request path and
 content-type. However, in Kafka it could be that folks send mixed Zipkin data without identifying
 its format. For example, Kafka historically has no content-type and users don't always segregate
 different queues by instrumentation format.]]>
    </doc>
  </class>
  <!-- end class zipkin2.SpanBytesDecoderDetector -->
</package>
<package name="zipkin2.codec">
  <!-- start interface zipkin2.codec.BytesDecoder -->
  <interface name="BytesDecoder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="encoding" return="zipkin2.codec.Encoding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serialized" type="byte[]"/>
      <param name="out" type="java.util.Collection"/>
      <doc>
      <![CDATA[This is used seldomly as the canonical message form is a {@link #decodeList(byte[], Collection)
 list}.

 <p>Note: multiple elements can be consumed from a single serialized object. For example, if the
 input is Zipkin v1, the list might receive two elements if the serialized object was a shared
 span.

 @param serialized a single message, for example a json object
 @return true if an element was decoded
 @throws {@linkplain IllegalArgumentException} if the type couldn't be decoded]]>
      </doc>
    </method>
    <method name="decodeOne" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serialized" type="byte[]"/>
      <doc>
      <![CDATA[Visible for testing. This returns the first element parsed from the serialized object or null]]>
      </doc>
    </method>
    <method name="decodeList" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serialized" type="byte[]"/>
      <param name="out" type="java.util.Collection"/>
      <doc>
      <![CDATA[@return true if an element was decoded
 @throws {@linkplain IllegalArgumentException} if the type couldn't be decoded]]>
      </doc>
    </method>
    <method name="decodeList" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serialized" type="byte[]"/>
      <doc>
      <![CDATA[Convenience method for {@link #decodeList(byte[], Collection)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This type accepts a collection that receives decoded elements.

 <pre>{@code
 ArrayList<Span> out = new ArrayList<>();
 SpanBytesDecoder.JSON_V2.decodeList(spans, out)
 }</pre>

 @param <T> type of the object to deserialize]]>
    </doc>
  </interface>
  <!-- end interface zipkin2.codec.BytesDecoder -->
  <!-- start interface zipkin2.codec.BytesEncoder -->
  <interface name="BytesEncoder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="encoding" return="zipkin2.codec.Encoding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="sizeInBytes" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
    </method>
    <method name="encode" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
      <doc>
      <![CDATA[Serializes an object into its binary form.]]>
      </doc>
    </method>
    <method name="encodeList" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.util.List"/>
      <doc>
      <![CDATA[Serializes a list of objects into their binary form.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@param <T> type of the object to deserialize]]>
    </doc>
  </interface>
  <!-- end interface zipkin2.codec.BytesEncoder -->
  <!-- start class zipkin2.codec.DependencyLinkBytesDecoder -->
  <class name="DependencyLinkBytesDecoder" extends="java.lang.Enum"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="zipkin2.codec.BytesDecoder"/>
    <method name="values" return="zipkin2.codec.DependencyLinkBytesDecoder[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="zipkin2.codec.DependencyLinkBytesDecoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="JSON_V1" type="zipkin2.codec.DependencyLinkBytesDecoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class zipkin2.codec.DependencyLinkBytesDecoder -->
  <!-- start class zipkin2.codec.DependencyLinkBytesEncoder -->
  <class name="DependencyLinkBytesEncoder" extends="java.lang.Enum"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="zipkin2.codec.BytesEncoder"/>
    <method name="values" return="zipkin2.codec.DependencyLinkBytesEncoder[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="zipkin2.codec.DependencyLinkBytesEncoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="JSON_V1" type="zipkin2.codec.DependencyLinkBytesEncoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class zipkin2.codec.DependencyLinkBytesEncoder -->
  <!-- start class zipkin2.codec.Encoding -->
  <class name="Encoding" extends="java.lang.Enum"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="zipkin2.codec.Encoding[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="zipkin2.codec.Encoding"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="listSizeInBytes" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedSizeInBytes" type="int"/>
      <doc>
      <![CDATA[Like {@link #listSizeInBytes(List)}, except for a single element.]]>
      </doc>
    </method>
    <method name="listSizeInBytes" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.List"/>
    </method>
    <field name="JSON" type="zipkin2.codec.Encoding"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="THRIFT" type="zipkin2.codec.Encoding"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="this format is deprecated in favor of json or proto3">
      <doc>
      <![CDATA[The first format of Zipkin was TBinaryProtocol, big-endian thrift. It is no longer used, but
 defined here to allow collectors to support reading old data.

 <p>The message's binary data includes a list header followed by N spans serialized in
 TBinaryProtocol

 @deprecated this format is deprecated in favor of json or proto3]]>
      </doc>
    </field>
    <field name="PROTO3" type="zipkin2.codec.Encoding"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Repeated (type 2) fields are length-prefixed. A list is a concatenation of fields with no
 additional overhead.

 <p>See https://developers.google.com/protocol-buffers/docs/encoding#optional]]>
      </doc>
    </field>
  </class>
  <!-- end class zipkin2.codec.Encoding -->
  <!-- start class zipkin2.codec.SpanBytesDecoder -->
  <class name="SpanBytesDecoder" extends="java.lang.Enum"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="zipkin2.codec.BytesDecoder"/>
    <method name="values" return="zipkin2.codec.SpanBytesDecoder[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="zipkin2.codec.SpanBytesDecoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="decodeList" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spans" type="java.nio.ByteBuffer"/>
      <param name="out" type="java.util.Collection"/>
      <doc>
      <![CDATA[ByteBuffer implementation of {@link #decodeList(byte[])}.

 <p>Note: only use this when it is ok to modify the underlying {@link ByteBuffer#array()}.]]>
      </doc>
    </method>
    <method name="decodeList" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spans" type="java.nio.ByteBuffer"/>
      <doc>
      <![CDATA[ByteBuffer implementation of {@link #decodeList(byte[])}.

 <p>Note: only use this when it is ok to modify the underlying {@link ByteBuffer#array()}.]]>
      </doc>
    </method>
    <method name="decodeOne" return="zipkin2.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="span" type="java.nio.ByteBuffer"/>
      <doc>
      <![CDATA[ByteBuffer implementation of {@link #decodeOne(byte[])}

 <p>Note: only use this when it is ok to modify the underlying {@link ByteBuffer#array()}.]]>
      </doc>
    </method>
    <field name="JSON_V1" type="zipkin2.codec.SpanBytesDecoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Corresponds to the Zipkin v1 json format]]>
      </doc>
    </field>
    <field name="THRIFT" type="zipkin2.codec.SpanBytesDecoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Corresponds to the Zipkin v1 thrift format]]>
      </doc>
    </field>
    <field name="JSON_V2" type="zipkin2.codec.SpanBytesDecoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Corresponds to the Zipkin v2 json format]]>
      </doc>
    </field>
    <field name="PROTO3" type="zipkin2.codec.SpanBytesDecoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This is separate from {@link SpanBytesEncoder}, as it isn't needed for instrumentation]]>
    </doc>
  </class>
  <!-- end class zipkin2.codec.SpanBytesDecoder -->
  <!-- start class zipkin2.codec.SpanBytesEncoder -->
  <class name="SpanBytesEncoder" extends="java.lang.Enum"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="zipkin2.codec.BytesEncoder"/>
    <method name="values" return="zipkin2.codec.SpanBytesEncoder[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="zipkin2.codec.SpanBytesEncoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="encodeList" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spans" type="java.util.List"/>
      <param name="out" type="byte[]"/>
      <param name="pos" type="int"/>
      <doc>
      <![CDATA[Allows you to encode a list of spans onto a specific offset. For example, when nesting]]>
      </doc>
    </method>
    <field name="JSON_V1" type="zipkin2.codec.SpanBytesEncoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Corresponds to the Zipkin v1 json format (with tags as binary annotations)]]>
      </doc>
    </field>
    <field name="THRIFT" type="zipkin2.codec.SpanBytesEncoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Corresponds to the Zipkin v1 thrift format]]>
      </doc>
    </field>
    <field name="JSON_V2" type="zipkin2.codec.SpanBytesEncoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Corresponds to the Zipkin v2 json format]]>
      </doc>
    </field>
    <field name="PROTO3" type="zipkin2.codec.SpanBytesEncoder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Limited interface needed by those writing span reporters]]>
    </doc>
  </class>
  <!-- end class zipkin2.codec.SpanBytesEncoder -->
</package>
<package name="zipkin2.storage">
  <!-- start interface zipkin2.storage.AutocompleteTags -->
  <interface name="AutocompleteTags"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKeys" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves the list of tag getKeys whose values may be returned by {@link #getValues(String)}.

 @see StorageComponent.Builder#autocompleteKeys(List)]]>
      </doc>
    </method>
    <method name="getValues" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Retrieves the list of values, if the input is configured for autocompletion. If a key is not
 configured, or there are no values available, an empty result will be returned.

 @throws IllegalArgumentException if the input is empty.
 @see StorageComponent.Builder#autocompleteKeys(List)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides autocomplete functionality by providing values for a given tag key, usually derived from
 {@link SpanConsumer}.]]>
    </doc>
  </interface>
  <!-- end interface zipkin2.storage.AutocompleteTags -->
  <!-- start class zipkin2.storage.ForwardingStorageComponent -->
  <class name="ForwardingStorageComponent" extends="zipkin2.storage.StorageComponent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ForwardingStorageComponent"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="zipkin2.storage.StorageComponent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The delegate is a method as opposed to a field, to allow for flexibility. For example, this
 allows you to choose to make a final or lazy field, or no field at all.]]>
      </doc>
    </method>
    <method name="spanConsumer" return="zipkin2.storage.SpanConsumer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="traces" return="zipkin2.storage.Traces"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="spanStore" return="zipkin2.storage.SpanStore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="autocompleteTags" return="zipkin2.storage.AutocompleteTags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serviceAndSpanNames" return="zipkin2.storage.ServiceAndSpanNames"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="check" return="zipkin2.CheckResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isOverCapacity" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Throwable"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[We provide a forwarding variant of the storage component for use cases such as trace decoration,
 or throttling.

 <p>Extending this is better than extending {@link StorageComponent} directly because it reduces
 risk of accidentally masking new methods. For example, if you extended storage component and
 later a new feature for cache control was added, that feature would be blocked until the wrapper
 was re-compiled. Such would be worse in most cases than not having decoration on new methods.

 @since 2.16]]>
    </doc>
  </class>
  <!-- end class zipkin2.storage.ForwardingStorageComponent -->
  <!-- start class zipkin2.storage.GroupByTraceId -->
  <class name="GroupByTraceId" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="zipkin2.Call.Mapper"/>
    <method name="create" return="zipkin2.Call.Mapper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strictTraceId" type="boolean"/>
    </method>
    <method name="map" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.util.List"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A mapper that groups unorganized input spans by trace ID. Useful when preparing a result for
 {@link SpanStore#getTraces(QueryRequest)}.]]>
    </doc>
  </class>
  <!-- end class zipkin2.storage.GroupByTraceId -->
  <!-- start class zipkin2.storage.InMemoryStorage -->
  <class name="InMemoryStorage" extends="zipkin2.storage.StorageComponent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="zipkin2.storage.SpanStore"/>
    <implements name="zipkin2.storage.SpanConsumer"/>
    <implements name="zipkin2.storage.AutocompleteTags"/>
    <implements name="zipkin2.storage.ServiceAndSpanNames"/>
    <implements name="zipkin2.storage.Traces"/>
    <method name="newBuilder" return="zipkin2.storage.InMemoryStorage.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptedSpanCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="accept" return="zipkin2.Call"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spans" type="java.util.List"/>
    </method>
    <method name="getTraces" return="zipkin2.Call"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="zipkin2.storage.QueryRequest"/>
    </method>
    <method name="getTraces" return="java.util.List"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used for testing. Returns all traces unconditionally.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used for testing. Returns all dependency links unconditionally.]]>
      </doc>
    </method>
    <method name="getTrace" return="zipkin2.Call"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="java.lang.String"/>
    </method>
    <method name="getTraces" return="zipkin2.Call"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceIds" type="java.lang.Iterable"/>
    </method>
    <method name="getServiceNames" return="zipkin2.Call"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRemoteServiceNames" return="zipkin2.Call"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.String"/>
    </method>
    <method name="getSpanNames" return="zipkin2.Call"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.String"/>
    </method>
    <method name="getDependencies" return="zipkin2.Call"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endTs" type="long"/>
      <param name="lookback" type="long"/>
    </method>
    <method name="getKeys" return="zipkin2.Call"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValues" return="zipkin2.Call"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="traces" return="zipkin2.storage.InMemoryStorage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="spanStore" return="zipkin2.storage.InMemoryStorage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="autocompleteTags" return="zipkin2.storage.InMemoryStorage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serviceAndSpanNames" return="zipkin2.storage.InMemoryStorage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="spanConsumer" return="zipkin2.storage.SpanConsumer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Test storage component that keeps all spans in memory, accepting them on the calling thread.

 <p>Internally, spans are indexed on 64-bit trace ID

 <p>Here's an example of some traces in memory:

 <pre>{@code
 spansByTraceIdTimeStamp:
    <aaaa,July 4> --> ( spanA(time:July 4, traceId:aaaa, service:foo, name:GET),
                        spanB(time:July 4, traceId:aaaa, service:bar, name:GET) )
    <cccc,July 4> --> ( spanC(time:July 4, traceId:aaaa, service:foo, name:GET) )
    <bbbb,July 5> --> ( spanD(time:July 5, traceId:bbbb, service:biz, name:GET) )
    <bbbb,July 6> --> ( spanE(time:July 6, traceId:bbbb) service:foo, name:POST )

 traceIdToTraceIdTimeStamps:
    aaaa --> [ <aaaa,July 4> ]
    bbbb --> [ <bbbb,July 5>, <bbbb,July 6> ]
    cccc --> [ <cccc,July 4> ]

 serviceToTraceIds:
    foo --> [ <aaaa>, <cccc>, <bbbb> ]
    bar --> [ <aaaa> ]
    biz --> [ <bbbb> ]

 serviceToSpanNames:
    bar --> ( GET )
    biz --> ( GET )
    foo --> ( GET, POST )
 }</pre>]]>
    </doc>
  </class>
  <!-- end class zipkin2.storage.InMemoryStorage -->
  <!-- start class zipkin2.storage.InMemoryStorage.Builder -->
  <class name="InMemoryStorage.Builder" extends="zipkin2.storage.StorageComponent.Builder"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="strictTraceId" return="zipkin2.storage.InMemoryStorage.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strictTraceId" type="boolean"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="searchEnabled" return="zipkin2.storage.InMemoryStorage.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="searchEnabled" type="boolean"/>
    </method>
    <method name="autocompleteKeys" return="zipkin2.storage.InMemoryStorage.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="autocompleteKeys" type="java.util.List"/>
    </method>
    <method name="maxSpanCount" return="zipkin2.storage.InMemoryStorage.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxSpanCount" type="int"/>
      <doc>
      <![CDATA[Eldest traces are removed to ensure spans in memory don't exceed this value]]>
      </doc>
    </method>
    <method name="build" return="zipkin2.storage.InMemoryStorage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class zipkin2.storage.InMemoryStorage.Builder -->
  <!-- start class zipkin2.storage.QueryRequest -->
  <class name="QueryRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="serviceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When present, corresponds to the {@link Span#localServiceName() local service name} and
 constrains all other parameters.

 @see ServiceAndSpanNames#getServiceNames()]]>
      </doc>
    </method>
    <method name="remoteServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When present, only include traces with this {@link Span#remoteServiceName() remote service
 name}.

 @see ServiceAndSpanNames#getRemoteServiceNames(String)]]>
      </doc>
    </method>
    <method name="spanName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When present, only include traces with this {@link Span#name()}

 @see ServiceAndSpanNames#getSpanNames(String)]]>
      </doc>
    </method>
    <method name="annotationQuery" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When an input value is the empty string, include traces whose {@link Span#annotations()}
 include a value in this set, or where {@link Span#tags()} include a key is in this set. When
 not, include traces whose {@link Span#tags()} an entry in this map.

 <p>Multiple entries are combined with AND, and AND against other conditions.]]>
      </doc>
    </method>
    <method name="minDuration" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Only return traces whose {@link Span#duration()} is greater than or equal to minDuration
 microseconds.]]>
      </doc>
    </method>
    <method name="maxDuration" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Only return traces whose {@link Span#duration()} is less than or equal to maxDuration
 microseconds. Only valid with {@link #minDuration}.]]>
      </doc>
    </method>
    <method name="endTs" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Only return traces where all {@link Span#timestamp()} are at or before this time in epoch
 milliseconds. Defaults to current time.]]>
      </doc>
    </method>
    <method name="lookback" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Only return traces where all {@link Span#timestamp()} are at or after (endTs - lookback) in
 milliseconds. Defaults to endTs.]]>
      </doc>
    </method>
    <method name="limit" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Maximum number of traces to return. Defaults to 10]]>
      </doc>
    </method>
    <method name="annotationQueryString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Corresponds to query parameter "annotationQuery". Ex. "http.method=GET and error"

 @see QueryRequest.Builder#parseAnnotationQuery(String)]]>
      </doc>
    </method>
    <method name="toBuilder" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newBuilder" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="test" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spans" type="java.util.List"/>
      <doc>
      <![CDATA[Tests the supplied trace against the current request.

 <p>This is used when the backend cannot fully refine a trace query.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Invoking this request retrieves traces matching the below filters.

 <p>Results should be filtered against {@link #endTs}, subject to {@link #limit} and {@link
 #lookback}. For example, if endTs is 10:20 today, limit is 10, and lookback is 7 days, traces
 returned should be those nearest to 10:20 today, not 10:20 a week ago.

 <p>Time units of {@link #endTs} and {@link #lookback} are milliseconds as opposed to
 microseconds, the grain of {@link Span#timestamp()}. Milliseconds is a more familiar and
 supported granularity for query, index and windowing functions.]]>
    </doc>
  </class>
  <!-- end class zipkin2.storage.QueryRequest -->
  <!-- start class zipkin2.storage.QueryRequest.Builder -->
  <class name="QueryRequest.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="serviceName" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceName" type="java.lang.String"/>
      <doc>
      <![CDATA[@see QueryRequest#serviceName()]]>
      </doc>
    </method>
    <method name="remoteServiceName" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="remoteServiceName" type="java.lang.String"/>
      <doc>
      <![CDATA[@see QueryRequest#remoteServiceName()]]>
      </doc>
    </method>
    <method name="spanName" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spanName" type="java.lang.String"/>
      <doc>
      <![CDATA[This ignores the reserved span name "all".

 @see QueryRequest#spanName()]]>
      </doc>
    </method>
    <method name="parseAnnotationQuery" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationQuery" type="java.lang.String"/>
      <doc>
      <![CDATA[Corresponds to query parameter "annotationQuery". Ex. "http.method=GET and error". Parameter keys and values are
 trimmed.

 @see QueryRequest#annotationQueryString()]]>
      </doc>
    </method>
    <method name="annotationQuery" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationQuery" type="java.util.Map"/>
      <doc>
      <![CDATA[@see QueryRequest#annotationQuery()]]>
      </doc>
    </method>
    <method name="minDuration" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="minDuration" type="java.lang.Long"/>
      <doc>
      <![CDATA[@see QueryRequest#minDuration()]]>
      </doc>
    </method>
    <method name="maxDuration" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDuration" type="java.lang.Long"/>
      <doc>
      <![CDATA[@see QueryRequest#maxDuration()]]>
      </doc>
    </method>
    <method name="endTs" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endTs" type="long"/>
      <doc>
      <![CDATA[@see QueryRequest#endTs()]]>
      </doc>
    </method>
    <method name="lookback" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookback" type="long"/>
      <doc>
      <![CDATA[@see QueryRequest#lookback()]]>
      </doc>
    </method>
    <method name="limit" return="zipkin2.storage.QueryRequest.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="int"/>
      <doc>
      <![CDATA[@see QueryRequest#limit()]]>
      </doc>
    </method>
    <method name="build" return="zipkin2.storage.QueryRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class zipkin2.storage.QueryRequest.Builder -->
  <!-- start interface zipkin2.storage.ServiceAndSpanNames -->
  <interface name="ServiceAndSpanNames"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getServiceNames" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves all {@link Span#localEndpoint() local} {@link Endpoint#serviceName() service names},
 sorted lexicographically.]]>
      </doc>
    </method>
    <method name="getRemoteServiceNames" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Retrieves all {@link Span#remoteEndpoint() remote} {@link Endpoint#serviceName() service names}
 recorded by a {@link Span#localEndpoint() service}, sorted lexicographically.]]>
      </doc>
    </method>
    <method name="getSpanNames" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Retrieves all {@link Span#name() span names} recorded by a {@link Span#localEndpoint()
 service}, sorted lexicographically.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides autocomplete functionality by providing values for service and span names, usually
 derived from {@link SpanConsumer}.]]>
    </doc>
  </interface>
  <!-- end interface zipkin2.storage.ServiceAndSpanNames -->
  <!-- start interface zipkin2.storage.SpanConsumer -->
  <interface name="SpanConsumer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spans" type="java.util.List"/>
    </method>
  </interface>
  <!-- end interface zipkin2.storage.SpanConsumer -->
  <!-- start interface zipkin2.storage.SpanStore -->
  <interface name="SpanStore"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTraces" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="zipkin2.storage.QueryRequest"/>
      <doc>
      <![CDATA[Retrieves spans grouped by trace ID from the storage system with no ordering expectation.

 <p>When strict trace ID is disabled, spans are grouped by the right-most 16 characters of the
 trace ID.]]>
      </doc>
    </method>
    <method name="getTrace" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link Traces#getTrace(String)}">
      <param name="traceId" type="java.lang.String"/>
      <doc>
      <![CDATA[Retrieves spans that share a 128-bit trace id with no ordering expectation or empty if none are
 found.

 <p>When strict trace ID is disabled, spans with the same right-most 16 characters are returned
 even if the characters to the left are not.

 <p>Implementations should use {@link Span#normalizeTraceId(String)} to ensure consistency.

 @param traceId the {@link Span#traceId() trace ID}
 @deprecated use {@link Traces#getTrace(String)}]]>
      </doc>
    </method>
    <method name="getServiceNames" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link ServiceAndSpanNames#getServiceNames()}">
      <doc>
      <![CDATA[Retrieves all {@link Span#localEndpoint() local} and {@link Span#remoteEndpoint() remote}
 {@link Endpoint#serviceName() service names}, sorted lexicographically.

 @deprecated use {@link ServiceAndSpanNames#getServiceNames()}]]>
      </doc>
    </method>
    <method name="getSpanNames" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link ServiceAndSpanNames#getSpanNames(String)}">
      <param name="serviceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Retrieves all {@link Span#name() span names} recorded by a {@link Span#localEndpoint()
 service}, sorted lexicographically.

 @deprecated use {@link ServiceAndSpanNames#getSpanNames(String)}]]>
      </doc>
    </method>
    <method name="getDependencies" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endTs" type="long"/>
      <param name="lookback" type="long"/>
      <doc>
      <![CDATA[Returns dependency links derived from spans in an interval contained by (endTs - lookback) or
 empty if none are found.

 <p>Implementations may bucket aggregated data, for example daily. When this is the case, endTs
 may be floored to align with that bucket, for example midnight if daily. lookback applies to
 the original endTs, even when bucketed. Using the daily example, if endTs was 11pm and lookback
 was 25 hours, the implementation would query against 2 buckets.

 <p>Some implementations parse spans from storage and call {@link
 DependencyLinker} to aggregate links. The reason is certain graph logic, such as skipping up
 the tree is difficult to implement as a storage query.

 <p>Spans are grouped by the right-most 16 characters of the trace ID. This ensures call counts
 are not incremented twice due to one hop downgrading from 128 to 64-bit trace IDs.

 @param endTs only return links from spans where {@link Span#timestamp()} are at or before this
 time in epoch milliseconds.
 @param lookback only return links from spans where {@link Span#timestamp()} are at or after
 (endTs - lookback) in milliseconds.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Queries data derived from {@link SpanConsumer}.

 <p>Note: This is not considered a user-level Api, rather an Spi that can be used to bind
 user-level abstractions such as futures or observables.]]>
    </doc>
  </interface>
  <!-- end interface zipkin2.storage.SpanStore -->
  <!-- start class zipkin2.storage.StorageComponent -->
  <class name="StorageComponent" extends="zipkin2.Component"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StorageComponent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="traces" return="zipkin2.storage.Traces"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="spanStore" return="zipkin2.storage.SpanStore"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="autocompleteTags" return="zipkin2.storage.AutocompleteTags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serviceAndSpanNames" return="zipkin2.storage.ServiceAndSpanNames"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="spanConsumer" return="zipkin2.storage.SpanConsumer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isOverCapacity" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[A storage request failed and was dropped due to a limit, resource unavailability, or a timeout.
 Implementations of throttling can use this signal to differentiate between failures, for
 example to reduce traffic.

 <p>Callers of this method will submit an exception raised by {@link Call#execute()} or on the
 error callback of {@link Call#enqueue(Callback)}.

 <p>By default, this returns true if the input is a {@link RejectedExecutionException}. When
 originating exceptions, use this type to indicate a load related failure.

 <p>It is generally preferred to specialize this method to handle relevant exceptions for the
 particular storage rather than wrapping them in {@link RejectedExecutionException} at call
 sites. Extra wrapping can make errors harder to read, for example, by making it harder to
 "google" a solution for a well known error message for the storage client, instead thinking the
 error is in Zipkin code itself.

 <h3>See also</h3>
 <p>While implementation is flexible, one known use is <a href="https://github.com/Netflix/concurrency-limits">Netflix
 concurrency limits</a>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A component that provides storage interfaces used for spans and aggregations. Implementations are
 free to provide other interfaces, but the ones declared here must be supported.

 @see InMemoryStorage]]>
    </doc>
  </class>
  <!-- end class zipkin2.storage.StorageComponent -->
  <!-- start class zipkin2.storage.StorageComponent.Builder -->
  <class name="StorageComponent.Builder" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="strictTraceId" return="zipkin2.storage.StorageComponent.Builder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strictTraceId" type="boolean"/>
      <doc>
      <![CDATA[Zipkin supports 64 and 128-bit trace identifiers, typically serialized as 16 or 32 character
 hex strings. When false, this setting only considers the low 64-bits (right-most 16
 characters) of a trace ID when grouping or retrieving traces. This should be set to false
 while some applications issue 128-bit trace IDs and while other truncate them to 64-bit. If
 128-bit trace IDs are not in use, this setting is not required.

 <h3>Details</h3>

 <p>Zipkin historically had 64-bit {@link Span#traceId() trace IDs}, but it now supports 128-
 bit trace IDs via 32-character hex representation. While instrumentation update to propagate
 128-bit IDs, it can be ambiguous whether a 64-bit trace ID was sent intentionally, or as an
 accident of truncation. This setting allows Zipkin to be usable until application
 instrumentation are upgraded to support 128-bit trace IDs.

 <p>Here are a few trace IDs the help explain this setting.

 <pre><ul>
   <li>Trace ID A: 463ac35c9f6413ad48485a3953bb6124</li>
   <li>Trace ID B: 48485a3953bb6124</li>
   <li>Trace ID C: 463ac35c9f6413adf1a48a8cff464e0e</li>
   <li>Trace ID D: 463ac35c9f6413ad</li>
 </ul></pre>

 <p>In the above example, Trace ID A and Trace ID B might mean they are in the same trace,
 since the lower-64 bits of the IDs are the same. This could happen if a server A created the
 trace and propagated it to server B which ran an older tracing library. Server B could have
 truncated the trace ID to lower-64 bits. When {@code strictTraceId == false}, spans matching
 either trace ID A or B would be returned in the same trace when searching by ID A or B. Spans
 with trace ID C or D wouldn't be when searching by ID A or B because trace IDs C and D don't
 share lower 64-bits (right-most 16 characters) with trace IDs A or B.

 <p>It is also possible that all servers are capable of handling 128-bit trace identifiers,
 but are configured to only send 64-bit ones. In this case, if {@code strictTraceId == false}
 trace ID A and B would clash and be put into the same trace, causing confusion. Moreover,
 there is overhead associated with indexing spans both by 64 and 128-bit trace IDs. When a
 site has finished upgrading to 128-bit trace IDs, they should enable this setting.

 <p>See https://github.com/openzipkin/b3-propagation/issues/6 for the status of
 known open source libraries on 128-bit trace identifiers.]]>
      </doc>
    </method>
    <method name="searchEnabled" return="zipkin2.storage.StorageComponent.Builder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="searchEnabled" type="boolean"/>
      <doc>
      <![CDATA[False is an attempt to disable indexing, leaving only {@link StorageComponent#traces()}
 supported. For example, query requests will be disabled.

 The use case is typically to support 100% sampled data, or when traces are searched using
 alternative means such as a logging index.

 <p>Refer to implementation docs for the impact of this parameter. Operations that use
 indexes should return empty as opposed to throwing an exception.]]>
      </doc>
    </method>
    <method name="autocompleteKeys" return="zipkin2.storage.StorageComponent.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.util.List"/>
      <doc>
      <![CDATA[Autocomplete is used by the UI to suggest getValues for site-specific tags, such as
 environment names. The getKeys here would appear in {@link Span#tags() span tags}. Good
 choices for autocomplete are limited in cardinality for the same reasons as service and span
 names.

 For example, "http.url" would be a bad choice for autocomplete, not just because it isn't
 site-specific (such as environment would be), but also as there are unlimited getValues due
 to factors such as unique ids in the path.

 @param keys controls the span values stored for auto-complete.]]>
      </doc>
    </method>
    <method name="autocompleteTtl" return="zipkin2.storage.StorageComponent.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="autocompleteTtl" type="int"/>
      <doc>
      <![CDATA[How long in milliseconds to suppress calls to write the same autocomplete key/value pair.]]>
      </doc>
    </method>
    <method name="autocompleteCardinality" return="zipkin2.storage.StorageComponent.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="autocompleteCardinality" type="int"/>
      <doc>
      <![CDATA[How many autocomplete key/value pairs to suppress at a time.]]>
      </doc>
    </method>
    <method name="build" return="zipkin2.storage.StorageComponent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class zipkin2.storage.StorageComponent.Builder -->
  <!-- start class zipkin2.storage.StrictTraceId -->
  <class name="StrictTraceId" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="filterSpans" return="zipkin2.Call.Mapper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="java.lang.String"/>
    </method>
    <method name="filterTraces" return="zipkin2.Call.Mapper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="zipkin2.storage.QueryRequest"/>
      <doc>
      <![CDATA[Filters the mutable input client-side when there's a clash on lower 64-bits of a trace ID.

 @see FilterTraces]]>
      </doc>
    </method>
    <method name="filterTraces" return="zipkin2.Call.Mapper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceIds" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Returns a function that filters its mutable input when it contains a trace not matching the
 specified trace IDs.

 <p>Make sure the input IDs are unique and {@link Span#normalizeTraceId(String) normalized}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Storage implementation often need to re-check query results when {@link
 StorageComponent.Builder#strictTraceId(boolean) strict trace ID} is disabled.]]>
    </doc>
  </class>
  <!-- end class zipkin2.storage.StrictTraceId -->
  <!-- start interface zipkin2.storage.Traces -->
  <interface name="Traces"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTrace" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="java.lang.String"/>
      <doc>
      <![CDATA[Retrieves spans that share a 128-bit trace id with no ordering expectation or empty if none are
 found.

 <p>When strict trace ID is disabled, spans with the same right-most 16 characters are returned
 even if the characters to the left are not.

 <p>Implementations should use {@link Span#normalizeTraceId(String)} to ensure consistency.

 @param traceId the {@link Span#traceId() trace ID}]]>
      </doc>
    </method>
    <method name="getTraces" return="zipkin2.Call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceIds" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Retrieves any traces with the specified IDs. Results return in any order, and can be empty.

 <p>When strict trace ID is disabled, spans with the same right-most 16 characters are returned
 even if the characters to the left are not.

 <p>Implementations should use {@link Span#normalizeTraceId(String)} on each input trace ID to
 ensure consistency.

 @param traceIds a list of unique {@link Span#traceId() trace IDs}.
 @return traces matching the supplied trace IDs, in any order]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows readback of traces by ID, as written by a {@link SpanConsumer}.

 <p>Specifically, this provides apis present when {@link StorageComponent.Builder#searchEnabled(boolean)
 search is disabled}.

 <p>Note: This is not considered a user-level Api, rather an Spi that can be used to bind
 user-level abstractions such as futures or observables.

 @since 2.17]]>
    </doc>
  </interface>
  <!-- end interface zipkin2.storage.Traces -->
</package>
<package name="zipkin2.v1">
  <!-- start class zipkin2.v1.V1Annotation -->
  <class name="V1Annotation" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="new code should use {@link Annotation}.">
    <implements name="java.lang.Comparable"/>
    <method name="create" return="zipkin2.v1.V1Annotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <param name="value" type="java.lang.String"/>
      <param name="endpoint" type="zipkin2.Endpoint"/>
    </method>
    <method name="timestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Annotation#timestamp()]]>
      </doc>
    </method>
    <method name="value" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Annotation#value()]]>
      </doc>
    </method>
    <method name="endpoint" return="zipkin2.Endpoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The host that reported this annotation or null if unknown.

 <p>In v2 format, this is analogous to {@link Span#localEndpoint()}.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="zipkin2.v1.V1Annotation"/>
      <doc>
      <![CDATA[Compares by {@link #timestamp()}, then {@link #value()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Like {@link zipkin2.Annotation}, except in v1 format the {@link Span#localEndpoint()} was
 repeated for each annotation.

 @deprecated new code should use {@link Annotation}.]]>
    </doc>
  </class>
  <!-- end class zipkin2.v1.V1Annotation -->
  <!-- start class zipkin2.v1.V1BinaryAnnotation -->
  <class name="V1BinaryAnnotation" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="new code should use {@link Span#tags()}.">
    <implements name="java.lang.Comparable"/>
    <method name="createAddress" return="zipkin2.v1.V1BinaryAnnotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.lang.String"/>
      <param name="endpoint" type="zipkin2.Endpoint"/>
      <doc>
      <![CDATA[Creates an address annotation, which is the same as {@link Span#remoteEndpoint()}]]>
      </doc>
    </method>
    <method name="createString" return="zipkin2.v1.V1BinaryAnnotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="endpoint" type="zipkin2.Endpoint"/>
      <doc>
      <![CDATA[Creates a tag annotation, which is the same as {@link Span#tags()} except duplicating the
 endpoint.

 <p>A special case is when the key is "lc" and value is empty: This substitutes for the {@link
 Span#localEndpoint()}.]]>
      </doc>
    </method>
    <method name="key" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The same as the key of a {@link Span#tags()} v2 span tag}]]>
      </doc>
    </method>
    <method name="type" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The thrift type for the value defined in Zipkin's thrift definition. Note this is not the
 TBinaryProtocol field type!]]>
      </doc>
    </method>
    <method name="stringValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The same as the value of a {@link Span#tags()} v2 span tag} or null if this is an address]]>
      </doc>
    </method>
    <method name="endpoint" return="zipkin2.Endpoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When {@link #stringValue()} is present, this is the same as the {@link Span#localEndpoint()}
 Otherwise, it is the same as the {@link Span#remoteEndpoint()}.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="zipkin2.v1.V1BinaryAnnotation"/>
      <doc>
      <![CDATA[Provides consistent iteration by {@link #key}]]>
      </doc>
    </method>
    <field name="TYPE_BOOLEAN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The defined in zipkin's thrift definition]]>
      </doc>
    </field>
    <field name="TYPE_STRING" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The type defined in zipkin's thrift definition]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This only supports binary annotations that map to {@link Span v2 span} data. Namely, this
 supports {@link Span#tags()}, {@link Span#localEndpoint()} and {@link Span#remoteEndpoint()}.

 <p>Specifically, this maps String and Boolean binary annotations, ignoring others.

 @deprecated new code should use {@link Span#tags()}.]]>
    </doc>
  </class>
  <!-- end class zipkin2.v1.V1BinaryAnnotation -->
  <!-- start class zipkin2.v1.V1Span -->
  <class name="V1Span" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="new code should use {@link Span}.">
    <method name="traceIdHigh" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When non-zero, the trace containing this span uses 128-bit trace identifiers.]]>
      </doc>
    </method>
    <method name="traceId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[lower 64-bits of the {@link Span#traceId()}]]>
      </doc>
    </method>
    <method name="id" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as {@link zipkin2.Span#id()} except packed into a long. Zero means root span.]]>
      </doc>
    </method>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as {@link zipkin2.Span#name()}]]>
      </doc>
    </method>
    <method name="parentId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The parent's {@link #id()} or zero if this the root span in a trace.]]>
      </doc>
    </method>
    <method name="timestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as {@link Span#timestampAsLong()}]]>
      </doc>
    </method>
    <method name="duration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as {@link Span#durationAsLong()}]]>
      </doc>
    </method>
    <method name="annotations" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as {@link Span#annotations()}, except each may be associated with {@link
 Span#localEndpoint()}]]>
      </doc>
    </method>
    <method name="binaryAnnotations" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@link Span#tags()} are allocated to binary annotations with a {@link
 V1BinaryAnnotation#stringValue()}. {@link Span#remoteEndpoint()} to those without.]]>
      </doc>
    </method>
    <method name="debug" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as {@link Span#debug()}]]>
      </doc>
    </method>
    <method name="serviceNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the distinct {@link Endpoint#serviceName() service names} that logged to this span.]]>
      </doc>
    </method>
    <method name="newBuilder" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[V1 spans are different than v2 especially as annotations repeat. Support is available to help
 migrate old code or allow for parsing older data formats.

 @deprecated new code should use {@link Span}.]]>
    </doc>
  </class>
  <!-- end class zipkin2.v1.V1Span -->
  <!-- start class zipkin2.v1.V1Span.Builder -->
  <class name="V1Span.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="traceIdHigh" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see V1Span#traceIdHigh()]]>
      </doc>
    </method>
    <method name="traceId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see V1Span#traceId()]]>
      </doc>
    </method>
    <method name="id" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see V1Span#id()]]>
      </doc>
    </method>
    <method name="clear" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="traceId" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="java.lang.String"/>
      <doc>
      <![CDATA[Same as {@link Span.Builder#traceId(String)}]]>
      </doc>
    </method>
    <method name="traceId" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="long"/>
      <doc>
      <![CDATA[@see V1Span#traceId()]]>
      </doc>
    </method>
    <method name="traceIdHigh" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceIdHigh" type="long"/>
      <doc>
      <![CDATA[@see V1Span#traceIdHigh()]]>
      </doc>
    </method>
    <method name="id" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="long"/>
      <doc>
      <![CDATA[@see V1Span#id()]]>
      </doc>
    </method>
    <method name="id" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
      <doc>
      <![CDATA[Same as {@link Span.Builder#id(String)}]]>
      </doc>
    </method>
    <method name="parentId" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentId" type="java.lang.String"/>
      <doc>
      <![CDATA[Same as {@link Span.Builder#parentId(String)}]]>
      </doc>
    </method>
    <method name="parentId" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentId" type="long"/>
      <doc>
      <![CDATA[@see V1Span#parentId()]]>
      </doc>
    </method>
    <method name="name" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[@see V1Span#name()]]>
      </doc>
    </method>
    <method name="timestamp" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <doc>
      <![CDATA[@see V1Span#timestamp()]]>
      </doc>
    </method>
    <method name="duration" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="long"/>
      <doc>
      <![CDATA[@see V1Span#duration()]]>
      </doc>
    </method>
    <method name="addAnnotation" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <param name="value" type="java.lang.String"/>
      <param name="endpoint" type="zipkin2.Endpoint"/>
      <doc>
      <![CDATA[@see V1Span#annotations()]]>
      </doc>
    </method>
    <method name="addBinaryAnnotation" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.lang.String"/>
      <param name="endpoint" type="zipkin2.Endpoint"/>
      <doc>
      <![CDATA[Creates an address annotation, which is the same as {@link Span#remoteEndpoint()}]]>
      </doc>
    </method>
    <method name="addBinaryAnnotation" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="endpoint" type="zipkin2.Endpoint"/>
      <doc>
      <![CDATA[Creates a tag annotation, which is the same as {@link Span#tags()} except duplicating the
 endpoint.

 <p>A key of "lc" and empty value substitutes for {@link Span#localEndpoint()}.]]>
      </doc>
    </method>
    <method name="debug" return="zipkin2.v1.V1Span.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="debug" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[@see V1Span#debug()]]>
      </doc>
    </method>
    <method name="build" return="zipkin2.v1.V1Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class zipkin2.v1.V1Span.Builder -->
  <!-- start class zipkin2.v1.V1SpanConverter -->
  <class name="V1SpanConverter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="zipkin2.v1.V1SpanConverter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="convert" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="zipkin2.v1.V1Span"/>
    </method>
    <method name="convert"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="zipkin2.v1.V1Span"/>
      <param name="sink" type="java.util.Collection"/>
    </method>
    <doc>
    <![CDATA[Allows you to split a v1 span when necessary. This can be the case when reading merged
 client+server spans from storage or parsing old data formats.

 <p>This type isn't thread-safe: it re-uses state to avoid re-allocations in conversion loops.]]>
    </doc>
  </class>
  <!-- end class zipkin2.v1.V1SpanConverter -->
  <!-- start class zipkin2.v1.V2SpanConverter -->
  <class name="V2SpanConverter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="zipkin2.v1.V2SpanConverter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="convert" return="zipkin2.v1.V1Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="zipkin2.Span"/>
    </method>
    <doc>
    <![CDATA[Allows you convert a v2 span into a v1 span. This is helpful for legacy storage which still use
 annotations. This shouldn't be used by new code.

 <p>This type isn't thread-safe: it re-uses state to avoid re-allocations in conversion loops.]]>
    </doc>
  </class>
  <!-- end class zipkin2.v1.V2SpanConverter -->
</package>

</api>
